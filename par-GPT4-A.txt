To generate a phylogenetic tree using the Fitch parsimony algorithm for the given character sequences, we will first calculate the distance between each pair of sequences based on the number of differing characters. Then, we can construct a tree using these distances.

Let's start by calculating the pairwise distances between your sequences labeled as H, C, G, and O.

Character Sequences:
H: TTAGCTACT
C: CTAGCTCCC
G: CTGGCCACT
O: CTGGACCCT
Pairwise Differences:
H vs C: Count the number of positions where the characters differ.
H vs G: Count the differences.
H vs O: Count the differences.
C vs G: Count the differences.
C vs O: Count the differences.
G vs O: Count the differences.
I'll compute these differences now and then use them to approximate the phylogenetic tree using a simple method suited for illustrating the Fitch parsimony principle. Let's do the computations.

Here are the pairwise differences between each of the sequences:

H vs C: 3 differences
H vs G: 3 differences
H vs O: 5 differences
C vs G: 4 differences
C vs O: 4 differences
G vs O: 2 differences
Using these distances, we can create a basic phylogenetic tree. A typical method for doing this might be neighbor joining or UPGMA for a simple implementation. However, since you're interested in using the Fitch parsimony algorithm, we should note that this algorithm itself doesn't construct trees but rather scores them based on the minimal number of evolutionary changes.

Let's illustrate a simple method for constructing a tree and then discuss how we might score it using Fitch's algorithm. We'll first use a simplistic approach to arrange these sequences into a tree based on their distances:

Start by connecting the sequences with the smallest number of differences (G and O).
Then, connect sequences to this pair based on the next smallest differences in a way that minimizes additional changes.
I'll sketch a tree based on this rationale. ​
Analysis

python
Always show details

Copy
import matplotlib.pyplot as plt
import networkx as nx

# Define a function to draw the tree
def draw_tree():
    # Create a graph
    G = nx.Graph()

    # Add nodes and edges based on the minimal spanning arrangement using the distance data
    G.add_edge('G', 'O', weight=2)  # Smallest difference
    # Connect G to H (since G-H has smaller differences than G-C)
    G.add_edge('G', 'H', weight=3)
    # Connect H to C
    G.add_edge('H', 'C', weight=3)
    
    # Draw the graph
    pos = nx.spring_layout(G)  # positions for all nodes
    plt.figure(figsize=(8, 5))
    
    # nodes
    nx.draw_networkx_nodes(G, pos, node_size=7000, node_color='skyblue')

    # edges
    weights = nx.get_edge_attributes(G, 'weight').values()
    nx.draw_networkx_edges(G, pos, width=2)

    # labels
    nx.draw_networkx_labels(G, pos, font_size=20, font_family='sans-serif')
    
    # edge weight labels
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')

    plt.axis('off')  # Turn off the axis
    plt.show()

# Call the function to draw the tree
draw_tree()

Here is a simple phylogenetic tree based on the pairwise distances between the sequences H, C, G, and O:

G and O are closest (2 differences), so they are connected first.
H is then connected to G (3 differences).
Finally, C is connected to H (3 differences).
This arrangement attempts to minimize the total evolutionary changes, but does not yet apply Fitch's algorithm. Fitch's algorithm would be used to score such a tree based on the minimal number of changes required at each ancestral node to produce the observed sequences at the leaves. If you need to calculate the score using Fitch's algorithm or make any adjustments to the tree, let me know! ​